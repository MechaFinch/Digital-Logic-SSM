

 this is where I'm putting the ISA
 data is little endian
 spaces at the start of lines means they're ignored by programs parsing this
 other characters mark information
 
 . marks an instruction's primary mnemonic
 , marks additional mnemonics for the same opcode
 > is an entry point, and is on the line with the instruction's table
 ~ is a binary control word
 
 arguments take the form <set of modifiers> <type>
 arguments after the mnemonic are comma separated and different forms are separated by OR, e.g. "label OR const word"
 mnemonic only types have an equivalent that is only different in how it's written in the assembly, written as (mnemonic only: <equivalent type>)
 
 modifiers
  - offset marks a label to be the difference between the instruction and label
  - short marks an offset label as being limited to the range +127 -128 (1 byte)
  - unsigned probably does nothing for the assembler but that isn't final
 
 types
  - byte = 1 byte
  - word = 2 bytes, lower then upper
  - label (mnemonic only: word)

 ----------------
 OPCODE
 |----|------|
 | op | args |
 |----|------|
 
 Description
 
 operand stack
 
 Microcode
 0000 0000 0000 0000 0000 0000 0000 0000
 
 ----------------
.NOP
 |----|
>| 00 |
 |----|
 
 Does nothing
 
 No change
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.PUSH byte
 |----|------|
>| 01 | byte |
 |----|------|
 
 Pushe byte
 
 ... ->
 ..., value
 
 decrement sp, load immediate to A
~0000 0000 0000 0001 0010 0000 0100 0011

 store A at sp
~0000 0000 0000 0000 0000 0000 0001 1010

 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
    
 ----------------
.PUSH word OR label
 |----|------|
>| 02 | word |
 |----|------|
 
 Push word
 
 ... ->
 ..., val_h, val_l
 
 decrement sp, load immediate to A
~0000 0000 0000 0001 0010 0000 0100 0011
 
 load immediate to B
~0000 0000 0000 0001 0000 0000 1000 0011

 store B at sp & decrement sp
~0000 0000 0000 0000 0010 0000 0010 1110

 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010

 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.POP
 |----|
>| 03 |
 |----|
 
 Pop 1 byte
 
 ..., value ->
 ...
 
 increment sp & next inst
~0000 0000 0000 0011 0011 0000 0000 0011
 
 ----------------
.POPW
 |----|
>| 04 |
 |----|
 
 Pop 2 bytes
 
 ..., value_h, value_l ->
 ...
 
 increment sp
~0000 0000 0000 0000 0011 0000 0000 0000
 
 increment sp & next inst
~0000 0000 0000 0011 0011 0000 0000 0011
 
 ----------------
.POP unsigned byte
 |----|------|
>| 05 | byte |
 |----|------|
 
 Pop n bytes
 Affects carry flag
 
 ..., <n bytes> ->
 ...
 
 load A with spl
~0000 0000 0000 0000 0000 0000 0101 0010
 
 load B with immediate
~0000 0000 0000 0001 0000 0000 1000 0011
 
 addsc, store B
~0000 0110 1010 0100 0000 0000 1000 0100
 
 load A with sph
~0000 0000 0000 0000 0000 0000 0101 0110
 
 add carry to A
~0000 0000 0000 0000 0000 0000 0100 0100
 
 store AB to sp
~0000 0000 0000 0000 0010 1000 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
 
.DUP
 |----|
>| 06 |
 |----|
 
 Duplicate byte
 
 ..., value ->
 ..., value, value
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0000 0100 0010
 
 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010

 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.DUPO1
 |----|
>| 07 |
 |----|
 
 Duplicate byte over 1 byte
 
 ..., value, byte ->
 ..., value, byte, value
 
 ----------------
.DUPO2
 |----|
>| 08 |
 |----|
 
 Duplicate byte over 2 bytes
 
 ..., value, <2 bytes> ->
 ..., value, <2 bytes>, value
 
 ----------------
.DUPON unsigned byte
 |----|------|
>| 09 | byte |
 |----|------|
 
 Duplicate byte over n bytes
 Sets the base pointer to an undefined value, use DUPONPB to avoid this
 
 ..., value, <n bytes> ->
 ..., value, <n bytes>, value
 
 ----------------
.DUPONPB unsigned byte
 |----|------|
>| 0A | byte |
 |----|------|
 
 Duplicate byte over n bytes, preserve base pointer
 
 ..., value, <n bytes> ->
 ..., value, <n bytes>, value
 
 ----------------
.DUPW
 |----|
>| 0B |
 |----|
 
 Duplicate word
 
 ..., value_h, value_l ->
 ..., value_h, value_l, value_h, value_l
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0000 0100 0010

 load sp to B, decrement sp
~0000 0000 0000 0000 0010 0000 1000 0010
 
 decrement sp
~0000 0000 0000 0000 0010 0000 0000 0000

 store B at sp, decrement sp
~0000 0000 0000 0000 0010 0000 0010 1110
 
 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010

 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.DUPWO1
 |----|
>| 0C |
 |----|
 
 Duplicate word over 1 byte
 
 ..., value_h, value_l, byte ->
 ..., value_h, value_l, byte, value_h, value_low
 
 ----------------
.DUPWO2
 |----|
>| 0D |
 |----|
 
 Duplicate word over 2 bytes
 Sets the base pointer to the address of the original value_h, use DUP2O2PB to avoid this
 
 ..., value_h, value_l, <2 bytes> ->
 ..., value_h, value_l, <2 bytes>, value_h, value_l
 
 ----------------
.DUPWO2PB
 |----|
>| 0E |
 |----|
 
 Duplicate word over 2 bytes, preserve base pointer
 
 ..., value_h, value_l, <2 bytes> ->
 ..., value_h, value_l, <2 bytes>, value_h, value_l
 
 ----------------
.DUPWON unsigned byte
 |----|------|
>| 0F | byte |
 |----|------|
 
 Duplicate word over n bytes
 Sets the base pointer to the address of the original value_h, use DUP2ONPB to avoid this
 
 ..., value_h, value_l, <n bytes> ->
 ..., value_h, value_l, <n bytes>, value_l
 
 ----------------
.DUPWONPB unsigned byte
 |----|------|
>| 10 | byte |
 |----|------|
 
 Duplicate word over n bytes, preserve base pointer
 
 ..., value_h, value_l, <n bytes> ->
 ..., value_h, value_l, <n bytes>, value_h, value_l
 
 ----------------
.SWAP
 |----|
>| 11 |
 |----|
 
 Swap bytes
 
 ..., value1, value2 ->
 ..., value2, value1
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0000 0100 0010
 
 load sp to B
~0000 0000 0000 0000 0000 0000 1000 0010
 
 store A at sp, decrement sp
~0000 0000 0000 0000 0010 0000 0010 1010
 
 store B at sp
~0000 0000 0000 0000 0000 0000 0010 1110
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.SWAPO1
 |----|
>| 12 |
 |----|
 
 Swap bytes over 1 byte
 
 ..., value1, byte, value2 ->
 ..., value2, byte, value1
 
 ----------------
.SWAPO2
 |----|
>| 13 |
 |----|
 
 Swap bytes over 2 bytes
 
 ..., value1, <2 bytes>, value2 ->
 ..., value2, <2 bytes>, value1
 
 ----------------
.SWAPON unsigned byte
 |----|------|
>| 14 | byte |
 |----|------|
 
 Swap bytes over n bytes
 Sets the base pointer to an undefined value, use SWAPONPB to avoid this
 
 ..., value1, <n bytes>, value2 ->
 ..., value2, <n bytes>, value1
 
 ----------------
.SWAPONPB unsigned byte
 |----|------|
>| 15 | byte |
 |----|------|
 
 Swap bytes over n bytes, preserve base pointer
 
 ..., value1, <n bytes>, value2 ->
 ..., value2, <n bytes>, value1
 
 ----------------
.SWAPW
 |----|
>| 16 |
 |----|
 
 Swap words
 Sets the base pointer to value2, use SWAPWPB to avoid this
 
 ..., value1_h, value1_l, value2_h, value2_l ->
 ..., value2_h, value2_l, value1_h, value1_l
 
 ----------------
.SWAPWPB
 |----|
>| 17 |
 |----|
 
 Swap words, preserve base pointer
 
 ..., value1_h, value1_l, value2_h, value2_l ->
 ..., value2_h, value2_l, value1_h, value1_l
 
 ----------------
.SWAPWO1
 |----|
>| 18 |
 |----|
 
 Swap words over 1 byte
 Sets the base pointer to value2, use SWAPO1PB to avoid this
 
 ..., value1_h, value1_l, byte, value2_h, value2_l ->
 ..., value2_h, value2_l, byte, value1_h, value1_l
 
 ----------------
.SWAPWO1PB
 |----|
>| 19 |
 |----|
 
 Swap words over 1 byte, preserve base pointer
 
 ..., value1_h, value1_l, byte, value2_h, value2_l ->
 ..., value2_h, value2_l, byte, value1_h, value1_l
 
 ----------------
.SWAPWO2
 |----|
>| 1A |
 |----|
 
 Swap words over 2 bytes
 Sets the base pointer to value2, use SWAPO2PB to avoid this
 
 ..., value1_h, value1_l, <2 bytes>, value2_h, value2_l ->
 ..., value2_h, value2_l, <2 bytes>, value1_h, value1_l
 
 ----------------
.SWAPWO2PB
 |----|
>| 1B |
 |----|
 
 Swap words over 2 bytes, preserve base pointer
 
 ..., value1_h, value1_l, <2 bytes>, value2_h, value2_l ->
 ..., value2_h, value2_l, <2 bytes>, value1_h, value1_l
 
 ----------------
.SWAPWON unsigned byte
 |----|------|
>| 1C | byte |
 |----|------|
 
 Swap words over n bytes
 Sets the base pointer to value2, use SWAPWONPB to avoid this
 
 ..., value1_h, value1_l, <n bytes>, value2_h, value2_l ->
 ..., value2_h, value2_l, <n bytes>, value1_h, value1_l
 
 ----------------
.SWAPWONPB unsigned byte
 |----|------|
>| 1D | byte |
 |----|------|
 
 Swap words over n bytes, preserve base pointer
 
 ..., value1_h, value1_l, <n bytes>, value2_h, value2_l ->
 ..., value2_h, value2_l, <n bytes>, value1_h, value1_l
 
 ----------------
.SWAPBW
 |----|
>| 1E |
 |----|
 
 Swaps a byte and a word
 
 ..., byte, word_h, word_l ->
 ..., word_h, word_l, byte
 
 ----------------
.SWAPWB
 |----|
>| 1F |
 |----|
 
 Swaps a word and a byte
 
 ..., word_h, word_l, byte ->
 ..., byte, word_h, word_l
 
 ----------------
.LOAD word OR label
 |----|------|
>| 20 | word |
 |----|------|
 
 Pushes the byte at the specified memory address
 
 ... ->
 ..., value
 
 load immediate to B
~0000 0000 0000 0001 0000 0000 1000 0011
 
 load immediate to A
~0000 0000 0000 0001 0000 0000 0100 0011
 
 load value at AB to A, decrement sp
~0000 0000 0000 0000 0010 0000 0100 0000
 
 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.LOADW word OR label
 |----|------|
>| 21 | word |
 |----|------|
 
 Pushes the word at the specified memory address
 
 ... ->
 ..., value_h, value_l

 ----------------
.PLOAD
 |----|
>| 22 |
 |----|
 
 Pushes the byte at [pointer]
 
 ..., pointer_h, pointer_l ->
 ..., value
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 load sp to A
~0000 0000 0000 0000 0000 0000 0100 0010
 
 load AB to A
~0000 0000 0000 0000 0000 0000 0100 0000
 
 store A to sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.PLOADW
 |----|
>| 23 |
 |----|
 
 Pushes the word at [pointer]
 
 ..., pointer_h, pointer_l ->
 ..., value_h, value_l
 
 ----------------
.ALOAD
 |----|
>| 24 |
 |----|
 
 Pushes the byte at [pointer + offset]
 
 ..., pointer_h, pointer_l, offset ->
 ..., value
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0000 0100 0010
 
 load sp to B, save inverse carry of 2A
~0000 0111 1011 0000 0000 0000 1000 0010
 
 store sign extension to sp, decrement sp
~0000 0000 0000 1100 0010 0000 0010 0110

 addsc, store to sp, increment sp
~0000 0110 1010 0100 0011 0000 0010 0110
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0000 0100 0010
 
 addwc, store to A, decrement sp
~0000 0000 0010 0100 0010 0000 0100 0100
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 load AB to A, increment sp
~0000 0000 0000 0000 0011 0000 0100 0000
 
 store A to sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.ALOADW
 |----|
>| 25 |
 |----|
 
 Pushes the word at [pointer + offset]
 
 ..., pointer_h, pointer_l, offset ->
 ..., value_h, value_l
 
 ----------------
.ALOAD word OR label
 |----|------|
>| 26 | word |
 |----|------|
 
 Pushes the byte at [pointer + offset]
 
 ..., offset ->
 ..., value
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0000 0100 0010
 
 load immediate to B, save inverse carry of 2A
~0000 0111 1011 0001 0000 0000 1000 0011
 
 store sign extension to sp, increment sp
~0000 0000 0000 1100 0011 0000 0010 0110
 
 addsc, store to sp, decrement sp
~0000 0110 1010 0100 0010 0000 0010 0110
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 load immediate to A
~0000 0000 0000 0001 0000 0000 0100 0011
 
 addwc, store to A
~0000 0000 0010 0100 0000 0000 0100 0100
 
 load sp to B
~0000 0000 0000 0000 0000 0000 1000 0010
 
 load AB to A
~0000 0000 0000 0000 0000 0000 0100 0000
 
 store A to sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.ALOADW word OR label
 |----|------|
>| 27 | word |
 |----|------|
 
 Pushes the word at [pointer + offset]
 
 ..., offset ->
 ..., value_h, value_l

 ----------------
.WALOAD
 |----|
>| 28 |
 |----|
 
 Pushes the byte at [pointer + offset]
 
 ..., pointer_h, pointer_l, offset_h, offset_l ->
 ..., value
 
 ----------------
.WALOADW
 |----|
>| 29 |
 |----|
 
 Pushes the word at [pointer + offset]
 
 ..., pointer_h, pointer_l, offset_h, offset_l ->
 ..., value_h, value_l
 
 ----------------
.WALOAD word OR label
 |----|------|
>| 2A | word |
 |----|------|
 
 Pushes the byte at [pointer + offset]
 
 ..., offset_h, offset_l ->
 ..., value
 
 ----------------
.WALOADW word OR label
 |----|------|
>| 2B | word |
 |----|------|
 
 Pushes the word at [pointer + offset]
 
 ..., offset_h, offset_l ->
 ..., value_h, value_l
 
 ----------------
.BPLOAD
 |----|
>| 2C |
 |----|
 
 Pushes the byte at [base pointer]
 
 ... ->
 ..., value
 
 ----------------
.BPLOADW
 |----|
>| 2D |
 |----|
 
 Pushes the word at [base pointer]
 
 ... ->
 ..., value_h, value_l
 
 ----------------
.BPALOAD
 |----|
>| 2E |
 |----|
 
 Pushes the byte at [base pointer + offset]
 
 ..., offset ->
 ..., value
 
 ----------------
.BPALOADW
 |----|
>| 2F |
 |----|
 
 Pushes the word at [base pointer + offset]
 
 ..., offset ->
 ..., value_h, value_l
 
 ----------------
.BPWALOAD
 |----|
>| 30 |
 |----|
 
 Pushes the byte at [base pointer + offset]
 
 ..., offset_h, offset_l ->
 ..., value
 
 ----------------
.BPWALOADW
 |----|
>| 31 |
 |----|
 
 Pushes the word at [base pointer + offset]
 
 ..., offset_h, offset_l ->
 ..., value_h, value_l
 
 ----------------
.STORE word OR label
 |----|------|
>| 32 | word |
 |----|------|
 
 Stores the byte to the specified memory address
 Sets the base pointer to the specified memory address, use STOREPB to avoid this
 
 ..., value ->
 ...
 
 load immediate to B
~0000 0000 0000 0001 0000 0000 1000 0011
 
 load immediate to A
~0000 0000 0000 0001 0000 0000 0100 0011

 put AB in bp
~0000 0000 0000 0000 0000 0101 0000 0000
 
 load sp to A
~0000 0000 0000 0000 0000 0000 0100 0010
 
 store A at bp, increment sp
~0000 0000 0000 0000 0011 0000 0010 1001
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011

 ----------------
.STOREPB word OR label
 |----|------|
>| 33 | word |
 |----|------|
 
 Stores the byte to the specified memory address while preserving the base pointer
 
 ..., value ->
 ...
 
 put bph in A, decrement sp
~0000 0000 0000 0000 0010 0000 0101 0101
 
 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 put bpl in A, decrement sp
~0000 0000 0000 0000 0010 0000 0101 0001
 
 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 load immediate to B, increment sp
~0000 0000 0000 0001 0011 0000 1000 0011
 
 load immediate to A, increment sp
~0000 0000 0000 0001 0011 0000 0100 0011
 
 put AB in bp
~0000 0000 0000 0000 0000 0101 0000 0000
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0000 0100 0010
 
 store A at bp, decrement sp
~0000 0000 0000 0000 0010 0000 0010 1001
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0000 0100 0010
 
 put AB in bp, increment sp
~0000 0000 0000 0000 0011 0101 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.STOREW word OR label
 |----|------|
>| 34 | word |
 |----|------|
 
 Stores the word to the specified memory address
 Sets the base pointer to the specified memory address, use STOREWPB to avoid this
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.STOREWPB word OR label
 |----|------|
>| 35 | word |
 |----|------|
 
 Stores the word to the specified memory address while preserving the base pointer
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.PSTORE
 |----|
>| 36 |
 |----|
 
 Stores the byte to [pointer]
 Sets the base pointer to the pointer, use PSTOREPB to avoid this
 
 ..., pointer_h, pointer_l, value ->
 ...
 
 ----------------
.PSTOREPB
 |----|
>| 37 |
 |----|
 
 Stores the byte to [pointer] while preserving the base pointer
 
 ..., pointer_h, pointer_l, value ->
 ...
 
 ----------------
.PSTOREW
 |----|
>| 38 |
 |----|
 
 Stores the word to [pointer]
 Sets the base pointer to the pointer, use PSTOREWPB to avoid this
 
 ..., pointer_h, pointer_l, value_h, value_l ->
 ...
 
 ----------------
.PSTOREWPB
 |----|
>| 39 |
 |----|
 
 Stores the word to [pointer] while preserving the base pointer
 
 ..., pointer_h, pointer_l, value_h, value_l ->
 ...
 
 ----------------
.ASTORE
 |----|
>| 3A |
 |----|
 
 Stores the byte to [pointer + offset]
 Sets the base pointer to the effective address, use ASTOREPB to avoid this
 
 ..., pointer_h, pointer_l, offset, value ->
 ...
 
 ----------------
.ASTOREPB
 |----|
>| 3B |
 |----|
 
 Stores the byte to [pointer + offset] while preserving the base pointer
 
 ..., pointer_h, pointer_l, offset, value ->
 ...
 
 ----------------
.ASTOREW
 |----|
>| 3C |
 |----|
 
 Stores the word to [pointer + offset]
 Sets the base pointer to the effective address, use ASTOREPB to avoid this
 
 ..., pointer_h, pointer_l, offset, value_h, value_l ->
 ...
 
 ----------------
.ASTOREWPB
 |----|
>| 3D |
 |----|
 
 Stores the word to [pointer + offset] while preserving the base pointer
 
 ..., pointer_h, pointer_l, offset, value_h, value_l ->
 ...
 
 ----------------
.ASTORE word OR label
 |----|------|
>| 3E | word |
 |----|------|
 
 Stores the byte to [pointer + offset]
 Sets the base pointer to the effective address, use ASTOREPB to avoid this
 
 ..., offset, value ->
 ...
 
 ----------------
.ASTOREPB word OR label
 |----|------|
>| 3F | word |
 |----|------|
 
 Stores the byte to [pointer + offset] while preserving the base pointer
 
 ..., offset, value ->
 ...
 
 ----------------
.ASTOREW word OR label
 |----|------|
>| 40 | word |
 |----|------|
 
 Stores the word to [pointer + offset]
 Sets the base pointer to the effective address, use ASTOREWPB to avoid this
 
 ..., offset, value_h, value_l ->
 ...
 
 ----------------
.ASTOREWPB word OR label
 |----|------|
>| 41 | word |
 |----|------|
 
 Stores the word to [pointer + offset] while preserving the base pointer
 
 ..., offset, value_h, value_l ->
 ...
 
 ----------------
.WASTORE
 |----|
>| 42 |
 |----|
 
 Stores the byte to [pointer + offset]
 Sets the base pointer to the effective address, use WASTOREPB to avoid this
 
 ..., pointer_h, pointer_l, offset_h, offset_l, value ->
 ...
 
 ----------------
.WASTOREPB
 |----|
>| 43 |
 |----|
 
 Stores the byte to [pointer + offset] while preserving the base pointer
 
 ..., pointer_h, pointer_l, offset_h, offset_l, value ->
 ...
 
 ----------------
.WASTOREW
 |----|
>| 44 |
 |----|
 
 Stores the word to [pointer + offset]
 Sets the base pointer to the effective address, use WASTOREWPB to avoid this
 
 ..., pointer_h, pointer_l, offset_h, offset_l, value_h, value_l ->
 ...
 
 ----------------
.WASTOREWPB
 |----|
>| 45 |
 |----|
 
 Stores the word to [pointer + offset] while preserving the base pointer
 
 ..., pointer_h, pointer_l, offset_h, offset_l, value_h, value_l ->
 ...
 
 ----------------
.WASTORE word OR label
 |----|------|
>| 46 | word |
 |----|------|
 
 Stores the byte to [pointer + offset]
 Sets the base pointer to the effective address, use WASTOREPB to avoid this
 
 ..., offset_h, offset_l, value ->
 ...
 
 ----------------
.WASTOREPB word OR label
 |----|------|
>| 47 | word |
 |----|------|
 
 Stores the byte to [pointer + offset] while preserving the base pointer
 
 ..., offset_h, offset_l, value ->
 ...
 
 ----------------
.WASTOREW word OR label
 |----|------|
>| 48 | word |
 |----|------|
 
 Stores the word to [pointer + offset]
 Sets the base pointer to the effective address, use WASTOREWPB to avoid this
 
 ..., offset_h, offset_l, value_h, value_l ->
 ...
 
 ----------------
.WASTOREWPB word OR label
 |----|------|
>| 49 | word |
 |----|------|
 
 Stores the word to [pointer + offset] while preserving the base pointer
 
 ..., offset_h, offset_l, value_h, value_l ->
 ...
 
 ----------------
.BPSTORE
 |----|
>| 4A |
 |----|
 
 Stores the byte to [base pointer]
 
 ..., value ->
 ...
 
 ----------------
.BPSTOREW
 |----|
>| 4B |
 |----|
 
 Stores the word to [base pointer]
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.BPASTORE
 |----|
>| 4C |
 |----|
 
 Stores the byte to [base pointer + offset]
 Sets the base pointer to the effective address, use BPASTOREPB to avoid this
 
 ..., offset, value ->
 ...
 
 ----------------
.BPASTOREPB
 |----|
>| 4D |
 |----|
 
 Stores the byte to [base pointer + offset] while preserving the base pointer
 
 ..., offset, value ->
 ...
 
 ----------------
.BPASTOREW
 |----|
>| 4E |
 |----|
 
 Stores the word to [base pointer + offset]
 Sets the base pointer to the effective address, use BPASTOREPB to avoid this
 
 ..., offset, value_h, value_l ->
 ...
 
 ----------------
.BPASTOREWPB
 |----|
>| 4F |
 |----|
 
 Stores the word to [base pointer + offset] while preserving the base pointer
 
 ..., offset, value_h, value_l ->
 ...
 
 ----------------
.BPASTORE byte
 |----|------|
>| 50 | byte |
 |----|------|
 
 Stores the byte to [base pointer + offset]
 Sets the base pointer to the effective address, use BPASTOREPB to avoid this
 
 ..., value ->
 ...
 
 ----------------
.BPASTOREPB byte
 |----|------|
>| 51 | byte |
 |----|------|
 
 Stores the byte to [base pointer + offset] while preserving the base pointer
 
 ..., value ->
 ...
 
 ----------------
.BPASTOREW byte
 |----|------|
>| 52 | byte |
 |----|------|
 
 Stores the word to [base pointer + offset]
 Sets the base pointer to the effective address, use BPASTOREPB to avoid this
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.BPASTOREWPB byte
 |----|------|
>| 53 | byte |
 |----|------|
 
 Stores the word to [base pointer + offset] while preserving the base pointer
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.BPWASTORE
 |----|
>| 54 |
 |----|
 
 Stores the byte to [base pointer + offset]
 Sets the base pointer to the effective address, use PBWASTOREPB to avoid this
 
 ..., offset_h, offset_l, value ->
 ...
 
 ----------------
.BPWASTOREPB
 |----|
>| 55 |
 |----|
 
 Stores the byte to [base pointer + offset] while preserving the base pointer
 
 ..., offset_h, offset_l, value ->
 ...
 
 ----------------
.BPWASTOREW
 |----|
>| 56 |
 |----|
 
 Stores the word to [base pointer + offset]
 Sets the base pointer to the effective address, use PBWASTOREPB to avoid this
 
 ..., offset_h, offset_l, value_h, value_l ->
 ...
 
 ----------------
.BPWASTOREWPB
 |----|
>| 57 |
 |----|
 
 Stores the word to [base pointer + offset] while preserving the base pointer
 
 ..., offset_h, offset_l, value_h, value_l ->
 ...
 
 ----------------
.BPWASTORE word
 |----|------|
>| 58 | word |
 |----|------|
 
 Stores the byte to [base pointer + offset]
 Sets the base pointer to the effective address, use BPWASTOREPB to avoid this
 
 ..., value ->
 ...
 
 ----------------
.BPWASTOREPB word
 |----|------|
>| 59 | word |
 |----|------|
 
 Stores the byte to [base pointer + offset] while preserving the base pointer
 
 ..., value ->
 ...
 
 ----------------
.BPWASTOREW word
 |----|------|
>| 5A | word |
 |----|------|
 
 Stores the word to [base pointer + offset]
 Sets the base pointer to the effective address, use BPWASTOREPB to avoid this
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.BPWASTOREWPB word
 |----|------|
>| 5B | word |
 |----|------|
 
 Stores the word to [base pointer + offset] while preserving the base pointer
 This opcode has the longest mnemonic, which stands for:
 Base Pointer Word-indexed Array Store, Word, Preserve Base
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.LEA  BPADD
 |----|
>| 5C |
 |----|
 
 Pushes the effective address of [base pointer + offset]
 Has alias BPADD
 
 ..., offset ->
 ..., addr_h, addr_l
 
 ----------------
.LEA byte  BPADD byte
 |----|------|
>| 5D | byte |
 |----|------|
 
 Pushes the effective address of [base pointer + offset]
 Has alias BPADD
 
 ... ->
 ..., addr_h, addr_l
 
 ----------------
.WLEA  BPADDW
 |----|
>| 5E |
 |----|
 
 Pushes the effective address of [base pointer + offset]
 Has alias BPADDW
 
 ..., offset_h, offset_l ->
 ..., addr_h, addr_l
 
 ----------------
.WLEA word  BPADDW word
 |----|------|
>| 5F | word |
 |----|------|
 
 Pushes the effective address of [base pointer + offset]
 Has alias BPADDW
 
 ... ->
 ..., addr_h, addr_l
 
 ----------------
.PUSHBP
 |----|
>| 60 |
 |----|
 
 Pushes the base pointer
 
 ... ->
 ..., bp_h, bp_l
 
 ----------------
.POPBP
 |----|
>| 61 |
 |----|
 
 Pops the base pointer
 
 ..., bp_h, bp_l ->
 ...

 ----------------
.SWAPBP
 |----|
>| 62 |
 |----|
 
 Swaps the base pointer with the top of the stack
 
 ..., value_h, value_l ->
 ..., bp_h, bp_l
 
 ----------------
.SETBP word
 |----|
>| 63 |
 |----|
 
 Sets the base pointer to the value
 
 No change
 
 ----------------
.INCBP
 |----|
>| 64 |
 |----|
 
 Increments the base pointer
 
 No change
 
 ----------------
.DECBP
 |----|
>| 65 |
 |----|
 
 Decrements the base pointer
 
 No change
 
 ----------------
.PUSHS
 |----|
>| 66 |
 |----|
 
 Pushes the byte at [base pointer] and increments the base pointer
 
 ... ->
 ..., value
 
 ----------------
.PUSHSW
 |----|
>| 67 |
 |----|
 
 Pushes the word at [base pointer] and increments the base pointer twice
 
 ... ->
 ..., value_h, value_l
 
 ----------------
.POPS
 |----|
>| 68 |
 |----|
 
 Pops the byte to [base pointer] and increments the base pointer
 
 ..., value ->
 ...
 
 ----------------
.POPSW
 |----|
>| 69 |
 |----|
 
 Pops the word to [base pointer] and increments the base pointer twice
 
 ..., value_h, value_l ->
 ...
 
 ----------------
.MOVS
 |----|
>| 6A |
 |----|
 
 Copies the byte at [base pointer] to [pointer] and increments both
 
 ..., pointer_h, pointer_l ->
 ..., pointer+1_h, pointer+1_l
 
 ----------------
.MOVSW
 |----|
>| 6B |
 |----|
 
 Copies the word at [base pointer] to [pointer] and increments both twice
 
 ..., pointer_h, pointer_l ->
 ..., pointer+2_h, pointer+2_l
 
 ----------------
.MOVSR
 |----|
>| 6C |
 |----|
 
 Copies the byte at [pointer] to [base pointer] and increments both
 
 ..., pointer_h, pointer_l ->
 ..., pointer+1_h, pointer+1_l
 
 ----------------
.MOVSRW
 |----|
>| 6D |
 |----|
 
 Copies the word at [pointer] to [base pointer] and increments both twice
 
 ..., pointer_h, pointer_l ->
 ..., pointer+2_h, pointer+2_l
 
 ----------------
.LOOP
 |----|
>| 6E |
 |----|
 
 Decrements the base pointer, jumps to the address if BP = 0
 
 ..., addr_h, addr_l ->
 ...
 
 ----------------
.LOOP word
 |----|
>| 6F |
 |----|
 
 Decrements the base pointer, jumps to the address if BP = 0
 
 No change
 
 ----------------
.UCE
 |----|
>| 70 |
 |----|
 
 Sets the condition flag if a = b (unsigned)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.UCE byte
 |----|------|
>| 71 | byte |
 |----|------|
 
 Sets the condition flag if a = b (unsigned)
 
 ..., valuea ->
 ...
 
 ----------------
.UCEW
 |----|
>| 72 |
 |----|
 
 Sets the condition flag if a = b (unsigned)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.UCEW word
 |----|------|
>| 73 | word |
 |----|------|
 
 Sets the condition flag if a = b (unsigned)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.UCNE
 |----|
>| 74 |
 |----|
 
 Sets the condition flag if a != b (unsigned)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.UCNE byte
 |----|------|
>| 75 | byte |
 |----|------|
 
 Sets the condition flag if a != b (unsigned)
 
 ..., valuea ->
 ...
 
 ----------------
.UCNEW
 |----|
>| 76 |
 |----|
 
 Sets the condition flag if a != b (unsigned)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.UCNEW word
 |----|------|
>| 77 | word |
 |----|------|
 
 Sets the condition flag if a != b (unsigned)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.UCG
 |----|
>| 78 |
 |----|
 
 Sets the condition flag if a > b (unsigned)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.UCG byte
 |----|------|
>| 79 | byte |
 |----|------|
 
 Sets the condition flag if a > b (unsigned)
 
 ..., valuea ->
 ...
 
 ----------------
.UCGW
 |----|
>| 7A |
 |----|
 
 Sets the condition flag if a > b (unsigned)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.UCGW word
 |----|------|
>| 7B | word |
 |----|------|
 
 Sets the condition flag if a > b (unsigned)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.UCGE
 |----|
>| 7C |
 |----|
 
 Sets the condition flag if a >= b (unsigned)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.UCGE byte
 |----|------|
>| 7D | byte |
 |----|------|
 
 Sets the condition flag if a >= b (unsigned)
 
 ..., valuea ->
 ...
 
 ----------------
.UCGEW
 |----|
>| 7E |
 |----|
 
 Sets the condition flag if a >= b (unsigned)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.UCGEW word
 |----|------|
>| 7F | word |
 |----|------|
 
 Sets the condition flag if a >= b (unsigned)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.UCL
 |----|
>| 80 |
 |----|
 
 Sets the condition flag if a < b (unsigned)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.UCL byte
 |----|------|
>| 81 | byte |
 |----|------|
 
 Sets the condition flag if a < b (unsigned)
 
 ..., valuea ->
 ...
 
 ----------------
.UCLW
 |----|
>| 82 |
 |----|
 
 Sets the condition flag if a < b (unsigned)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.UCLW word
 |----|------|
>| 83 | word |
 |----|------|
 
 Sets the condition flag if a < b (unsigned)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.UCLE
 |----|
>| 84 |
 |----|
 
 Sets the condition flag if a <= b (unsigned)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.UCLE byte
 |----|------|
>| 85 | byte |
 |----|------|
 
 Sets the condition flag if a <= b (unsigned)
 
 ..., valuea ->
 ...
 
 ----------------
.UCLEW
 |----|
>| 86 |
 |----|
 
 Sets the condition flag if a <= b (unsigned)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.UCLEW word
 |----|------|
>| 87 | word |
 |----|------|
 
 Sets the condition flag if a <= b (unsigned)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.SCE
 |----|
>| 88 |
 |----|
 
 Sets the condition flag if a = b (signed)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.SCE byte
 |----|------|
>| 89 | byte |
 |----|------|
 
 Sets the condition flag if a = b (signed)
 
 ..., valuea ->
 ...
 
 ----------------
.SCEW
 |----|
>| 8A |
 |----|
 
 Sets the condition flag if a = b (signed)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.SCEW word
 |----|------|
>| 8B | word |
 |----|------|
 
 Sets the condition flag if a = b (signed)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.SCNE
 |----|
>| 8C |
 |----|
 
 Sets the condition flag if a != b (signed)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.SCNE byte
 |----|------|
>| 8D | byte |
 |----|------|
 
 Sets the condition flag if a != b (signed)
 
 ..., valuea ->
 ...
 
 ----------------
.SCNEW
 |----|
>| 8E |
 |----|
 
 Sets the condition flag if a != b (signed)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.SCNEW word
 |----|------|
>| 8F | word |
 |----|------|
 
 Sets the condition flag if a != b (signed)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.SCG
 |----|
>| 90 |
 |----|
 
 Sets the condition flag if a > b (signed)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.SCG byte
 |----|------|
>| 91 | byte |
 |----|------|
 
 Sets the condition flag if a > b (signed)
 
 ..., valuea ->
 ...
 
 ----------------
.SCGW
 |----|
>| 92 |
 |----|
 
 Sets the condition flag if a > b (signed)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.SCGW word
 |----|------|
>| 93 | word |
 |----|------|
 
 Sets the condition flag if a > b (signed)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.SCGE
 |----|
>| 94 |
 |----|
 
 Sets the condition flag if a >= b (signed)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.SCGE byte
 |----|------|
>| 95 | byte |
 |----|------|
 
 Sets the condition flag if a >= b (signed)
 
 ..., valuea ->
 ...
 
 ----------------
.SCGEW
 |----|
>| 96 |
 |----|
 
 Sets the condition flag if a >= b (signed)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.SCGEW word
 |----|------|
>| 97 | word |
 |----|------|
 
 Sets the condition flag if a >= b (signed)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.SCL
 |----|
>| 98 |
 |----|
 
 Sets the condition flag if a < b (signed)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.SCL byte
 |----|------|
>| 99 | byte |
 |----|------|
 
 Sets the condition flag if a < b (signed)
 
 ..., valuea ->
 ...
 
 ----------------
.SCLW
 |----|
>| 9A |
 |----|
 
 Sets the condition flag if a < b (signed)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.SCLW word
 |----|------|
>| 9B | word |
 |----|------|
 
 Sets the condition flag if a < b (signed)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.SCLE
 |----|
>| 9C |
 |----|
 
 Sets the condition flag if a <= b (signed)
 
 ..., valuea, valueb ->
 ...
 
 ----------------
.SCLE byte
 |----|------|
>| 9D | byte |
 |----|------|
 
 Sets the condition flag if a <= b (signed)
 
 ..., valuea ->
 ...
 
 ----------------
.SCLEW
 |----|
>| 9E |
 |----|
 
 Sets the condition flag if a <= b (signed)
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ...
 
 ----------------
.SCLEW word
 |----|------|
>| 9F | word |
 |----|------|
 
 Sets the condition flag if a <= b (signed)
 
 ..., valuea_h, valuea_l ->
 ...
 
 ----------------
.JMPS
 |----|
>| A0 |
 |----|
 
 Jumps by the 1-byte displacement relative to the next instruction
 
 ..., disp ->
 ...
 
 load sp to A
~0000 0000 0000 0000 0000 0000 0100 0010
 
 put ipl in B, save inverse carry of 2A
~0000 0111 1011 0000 0000 0000 1001 0011
 
 store sign extension to sp, decrement sp
~0000 0000 0000 1100 0010 0000 0010 0110
 
 addsc, store to sp, increment sp
~0000 0110 1010 0100 0011 0000 0010 0110
 
 load sp to B, decrement sp
~0000 0000 0000 0000 0010 0000 1000 0010
 
 put iph in A
~0000 0000 0000 0000 0000 0000 0101 0111
 
 addwc, store to A
~0000 0000 0010 0100 0000 0000 0100 0100
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 put AB in ip, increment sp
~0000 0000 0000 0001 1011 0000 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.JMPS byte OR short offset label
 |----|------|
>| A1 | byte |
 |----|------|
 
 Jumps by the 1-byte displacement relative to the next instruction
 
 No change
 
 load immediate to A
~0000 0000 0000 0001 0000 0000 0100 0011
 
 put ipl in B, save inverse carry of 2A, decrement sp
~0000 0111 1011 0000 0010 0000 1001 0011
 
 store sign extension to sp, decrement sp
~0000 0000 0000 1100 0010 0000 0010 0110
 
 addsc, store to sp, increment sp
~0000 0110 1010 0100 0011 0000 0010 0110
 
 load sp to B, decrement sp
~0000 0000 0000 0000 0010 0000 1000 0010
 
 put iph in A
~0000 0000 0000 0000 0000 0000 0101 0111
 
 addwc, store to A
~0000 0000 0010 0100 0000 0000 0100 0100
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 put AB in ip, increment sp
~0000 0000 0000 0001 1011 0000 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.JMPSC
 |----|
>| A2 |
 |----|
 
 Jumps by the 1-byte displacement relative to the next instruction if condition is set
 
 ..., disp ->
 ...
 
 ----------------
.JMPSC byte OR short offset label
 |----|------|
>| A3 | byte |
 |----|------|
 
 Jumps by the 1-byte displacement relative to the next instruction if condition is set
 
 No change
 
 ----------------
.JMPSN
 |----|
>| A4 |
 |----|
 
 Jumps by the 1-byte displacement relative to the next instruction if condition is not set
 
 ..., disp ->
 ...
 
 ----------------
.JMPSN byte OR short offset label
 |----|------|
>| A5 | byte |
 |----|------|
 
 Jumps by the 1-byte displacement relative to the next instruction if condition is not set
 
 No change
 
 ----------------
.JMPL
 |----|
>| A6 |
 |----|
 
 Jumps to the address
 
 ..., addr_h, addr_l ->
 ...
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0000 1000 0010
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0000 0100 0010
 
 put AB in ip
~0000 0000 0000 0001 1000 0000 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.JMPL word OR label
 |----|------|
>| A7 | word |
 |----|------|
 
 Jumps to the address
 
 No change
 
 load immediate to B
~0000 0000 0000 0001 0000 0000 1000 0011
 
 load immediate to A
~0000 0000 0000 0001 0000 0000 0100 0011
 
 put AB in ip
~0000 0000 0000 0001 1000 0000 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.JMPLC
 |----|
>| A8 |
 |----|
 
 Jumps to the address if condition is set
 
 ..., addr_h, addr_l ->
 ...
 
 ----------------
.JMPLC word OR label
 |----|------|
>| A9 | word |
 |----|------|
 
 Jumps to the address if condition is set
 
 No change
 
 ----------------
.JMPLN
 |----|
>| AA |
 |----|
 
 Jumps to the address if condition is not set
 
 ..., addr_h, addr_l ->
 ...
 
 ----------------
.JMPLN word OR label
 |----|------|
>| AB | word |
 |----|------|
 
 Jumps to the address if condition is not set
 
 No change
 
 ----------------
.CALL
 |----|
>| AC |
 |----|
 
 Pushes IP then jumps to the address
 
 ..., addr_h, addr_l ->
 ..., ip_h, ip_l
 
 ----------------
.CALL word OR label
 |----|------|
>| AD | word |
 |----|------|
 
 Pushes IP then jumps to the address
 
 ... ->
 ..., ip_h, ip_l
 
 ----------------
.RET
 |----|
>| AE |
 |----|
 
 Pops IP
 
 ..., ip_h, ip_l ->
 ...
 
 ----------------
.RET unsigned byte
 |----|
>| AF |
 |----|
 
 Pops IP then pops n bytes
 
 ..., <n bytes>, ip_h, ip_l ->
 ...

 ----------------
.ENTER byte
 |----|------|
>| B0 | byte |
 |----|------|
 
 Pushes BP, sets BP to SP, adds the value to SP
 
 ... ->
 ..., bp_h, bp_l, <value bytes of uninitialized data>
 
 ----------------
.ENTER word
 |----|------|
>| B1 | word |
 |----|------|
 
 Pushes BP, sets BP to SP, adds the value to SP
 
 ... ->
 ..., bp_h, bp_l, <value bytes of uninitialized data>
 
 ----------------
.LEAVE
 |----|
>| B2 |
 |----|
 
 Sets SP to BP, pops BP
 
 ..., bp_h, bp_l, ... ->
 ...
 
 ----------------
.ADD
 |----|
>| C0 |
 |----|
 
 Add bytes
 
 ..., valuea, valueb ->
 ..., a+b
 
 ----------------
.ADDC
 |----|
>| C1 |
 |----|
 
 Add bytes with carry
 
 ..., valuea, valueb ->
 ..., a+b+c
 
 ----------------
.ADD byte
 |----|------|
>| C2 | byte |
 |----|------|
 
 Add immediate byte
 
 ..., value ->
 ..., value+imm
 
 ----------------
.ADDC byte
 |----|------|
>| C3 | byte |
 |----|------|
 
 Add immediate byte with carry
 
 ..., value ->
 ..., value+imm+c
 
 ----------------
.ADDW
 |----|
>| C4 |
 |----|
 
 Add words
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a+b_h, a+b_l
 
 ----------------
.ADDWC
 |----|
>| C5 |
 |----|
 
 Add words with carry
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a+b+c_h, a+b+c_l
 
 ----------------
.ADDW word
 |----|------|
>| C6 | word |
 |----|------|
 
 Add immediate word
 
 ..., value_h, value_l ->
 ..., value+imm_h, value+imm_l
 
 ----------------
.ADDWC word
 |----|------|
>| C7 | word |
 |----|------|
 
 Add immediate word with carry
 
 ..., value_h, value_l ->
 ..., value+imm+c_h, value+imm+c_l
 
 ----------------
.SUB
 |----|
>| C8 |
 |----|
 
 Subtract bytes
 
 ..., valuea, valueb ->
 ..., a-b
 
 ----------------
.SUBB
 |----|
>| C9 |
 |----|
 
 Subtract bytes with borrow
 
 ..., valuea, valueb ->
 ..., a-b-c
 
 ----------------
.SUB byte
 |----|------|
>| CA | byte |
 |----|------|
 
 Subtract immediate byte
 
 ..., value ->
 ..., value-imm
 
 ----------------
.SUBB byte
 |----|------|
>| CB | byte |
 |----|------|
 
 Subtract immediate byte with borrow
 
 ..., value ->
 ..., value-imm-c
 
 ----------------
.SUBW
 |----|
>| CC |
 |----|
 
 Subtract words
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a-b_h, a-b_l
 
 ----------------
.SUBWB
 |----|
>| CD |
 |----|
 
 Subtract words with borrow
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a-b-c_h, a-b-c_l
 
 ----------------
.SUBW word
 |----|------|
>| CE | word |
 |----|------|
 
 Subtract immediate word
 
 ..., value_h, value_l ->
 ..., value-imm_h, value-imm_l
 
 ----------------
.SUBWB word
 |----|------|
>| CF | word |
 |----|------|
 
 Subtract immediate word with borrow
 
 ..., value_h, value_l ->
 ..., value-imm-c_h, value-imm-c_l
 
 ----------------
.AND
 |----|
>| D0 |
 |----|
 
 Bitwise logical AND, bytes
 
 ..., valuea, valueb ->
 ..., a&b
 
 ----------------
.AND byte
 |----|------|
>| D1 | byte |
 |----|------|
 
 Immediate bitwise logical AND, bytes
 
 ..., value ->
 ..., value&imm
 
 ----------------
.ANDW
 |----|
>| D2 |
 |----|
 
 Bitwise logical AND, words
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a&b_h, a&b_l
 
 ----------------
.ANDW word
 |----|------|
>| D3 | word |
 |----|------|
 
 Immediate bitwise logical AND, words
 
 ..., value_h, value_l ->
 ..., value&imm_h, value&imm_l
 
 ----------------
.OR
 |----|
>| D4 |
 |----|
 
 Bitwise logical OR, bytes
 
 ..., valuea, valueb ->
 ..., a|b
 
 ----------------
.OR byte
 |----|------|
>| D5 | byte |
 |----|------|
 
 Immediate bitwise logical OR, bytes
 
 ..., value ->
 ..., value|imm
 
 ----------------
.ORW
 |----|
>| D6 |
 |----|
 
 Bitwise logical OR, words
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a|b_h, a|b_l
 
 ----------------
.ORW word
 |----|------|
>| D7 | word |
 |----|------|
 
 Immediate bitwise logical OR, words
 
 ..., value_h, value_l ->
 ..., value|imm_h, value|imm_l
 
 ----------------
.XOR
 |----|
>| D8 |
 |----|
 
 Bitwise logical XOR, bytes
 
 ..., valuea, valueb ->
 ..., a^b
 
 ----------------
.XOR byte
 |----|------|
>| D9 | byte |
 |----|------|
 
 Immediate bitwise logical XOR, bytes
 
 ..., value ->
 ..., value^imm
 
 ----------------
.XORW
 |----|
>| DA |
 |----|
 
 Bitwise logical XOR, words
 
 ..., valuea_h, valuea_l, valueb_h, valueb_l ->
 ..., a^b_h, a^b_l
 
 ----------------
.XORW word
 |----|------|
>| DB | word |
 |----|------|
 
 Immediate bitwise logical XOR, words
 
 ..., value_h, value_l ->
 ..., value^imm_h, value^imm_l
 
 ----------------
.NOT
 |----|
>| DC |
 |----|
 
 Bitwise logical NOT, byte
 
 ..., value ->
 ..., !value
 
 ----------------
.NOTW
 |----|
>| DD |
 |----|
 
 Bitwise logical NOT, word
 
 ..., value_h, value_l ->
 ..., !value_h, !value_l
 
 ----------------
.SHL
 |----|
>| DE |
 |----|
 
 Shift left, byte
 
 ..., value ->
 ..., value<<1
 
 ----------------
.SHLW
 |----|
>| DF |
 |----|
 
 Shift left, word
 
 ..., value_h, value_l ->
 ..., value<<1_h, value<<1_l
 
 ----------------
.SRA
 |----|
>| E0 |
 |----|
 
 Arithmetic shift right, byte
 
 ..., value ->
 ..., value>>1
 
 ----------------
.SRAW
 |----|
>| E1 |
 |----|
 
 Arithmetic shift right, word
 
 ..., value_h, value_l ->
 ..., value>>1_h, value>>1_l
 
 ----------------
.SRL
 |----|
>| E2 |
 |----|
 
 Logical shift right, byte
 
 ..., value ->
 ..., value>>>1
 
 ----------------
.SRLW
 |----|
>| E3 |
 |----|
 
 Logical shift right, word
 
 ..., value_h, value_l ->
 ..., value>>>1_h, value>>>1_l
 
 ----------------
.POPU1
 |----|
>| F0 |
 |----|
 
 Pops the byte 1 byte below
 
 ..., value, byte ->
 ..., byte
 
 ----------------
.POPU2
 |----|
>| F1 |
 |----|
 
 Pops the byte 2 bytes below
 
 ..., value, <2 bytes> ->
 ..., <2 bytes>
 
 ----------------
.POPWU1
 |----|
>| F2 |
 |----|
 
 Pops the word 1 byte below
 
 ..., value_h, value_l, byte ->
 ..., byte
 
 ----------------
.POPWU2
 |----|
>| F3 |
 |----|
 
 Pops the word 2 bytes below
 
 ..., value_h, value_l, <2 bytes> ->
 ..., <2 bytes>
 
 ----------------
.READ
 |----|
>| F9 |
 |----|
 
 Reads the lower byte from IO
 
 ... ->
 ..., value
 
 decrement sp, load IOl to A
~0000 0000 0000 0000 0010 0000 0101 1000

 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010

 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.READW
 |----|
>| FA |
 |----|
 
 Reads the word from IO
 
 ... ->
 ..., value_h, value_l
 
 decrement sp, load IO to A
~0000 0000 0000 0000 0010 0000 0101 1000

 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 decrement sp, load IO to A
~0000 0000 0000 0000 0010 0000 0101 1000

 store A at sp
~0000 0000 0000 0000 0000 0000 0010 1010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.WRITE
 |----|
>| FB |
 |----|
 
 Writes the byte to IO
 
 ..., value ->
 ...
 
 write stack to IO
~1000 0000 0000 0000 0000 0000 0000 0010
 
 increment sp & next inst
~0000 0000 0000 0011 0011 0000 0000 0011
 
 ----------------
.WRITEW
 |----|
>| FC |
 |----|
 
 Writes the word to IO
 
 ..., value_h, value_l ->
 ...
 
 write stack to IO, increment sp
~1000 0000 0000 0000 0011 0000 0000 0010
 
 write stack to IO, increment sp
~1000 0000 0000 0000 0011 0000 0000 0010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.WRITEI byte
 |----|------|
>| FD | byte |
 |----|------|
 
 Writes the byte to IO
 
 No change
 
 write immediate to IO
~1000 0000 0000 0001 0000 0000 0000 0011
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
.WRITEIW word
 |----|------|
>| FE | word |
 |----|------|
 
 Writes the word to IO
 
 No change
 
 write immediate to IO
~1000 0000 0000 0001 0000 0000 0000 0011
 
 write immediate to IO
~1000 0000 0000 0001 0000 0000 0000 0011
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ---------------- 
.WRITEUIW byte
 |----|------|
>| FF | byte |
 |----|------|
 
 Writes two bytes to IO where the first is immediate
 
 ..., value ->
 ...
 
 write immediate to IO
~1000 0000 0000 0001 0000 0000 0000 0011
 
 write stack to IO, increment sp
~1000 0000 0000 0000 0011 0000 0000 0010
 
 next inst
~0000 0000 0000 0011 0000 0000 0000 0011
 
 ----------------
 
 
 
