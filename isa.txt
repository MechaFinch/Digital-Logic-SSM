

 this is where I'm putting the ISA
 data is little endian
 spaces at the start of lines means they're ignored by programs parsing this
 other characters mark information
 
 . marks an instruction's primary mnemonic
 , marks additional mnemonics for the same opcode
 > is an entry point, and is on the line with the instruction's table
 ~ is a binary control word
 
 arguments take the form <set of modifiers> <type>
 arguments after the mnemonic are comma separated and different forms are separated by OR, e.g. "label OR const word"
 mnemonic only types have an equivalent that is only different in how it's written in the assembly, written as (mnemonic only: <equivalent type>)
 
 modifiers
  - offset marks a label to be the difference between the instruction and label
  - unsigned probably does nothing for the assembler but that isn't final
 
 types
  - byte = 1 byte
  - word = 2 bytes, lower then upper
  - label (mnemonic only: word)

 ----------------
 OPCODE
 |----|------|
 | op | args |
 |----|------|
 
 Description
 
 operand stack
 
 Microcode
 0000 0000 0000 0000 0000 0000 0000 0000
 
 ----------------
.NOP
 |----|
>| 00 |
 |----|
 
 Does nothing
 
 No change
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.PUSH byte
 |----|------|
>| 01 | byte |
 |----|------|
 
 Pushes a byte
 
 ... ->
 ..., value
 
 decrement sp, load constant to A
~0000 0000 0000 0001 0010 0001 0010 0011

 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010

 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
    
 ----------------
.PUSH word OR label
 |----|------|
>| 02 | word |
 |----|------|
 
 Pushes an address
 
 ... ->
 ... val_h, val_l
 
 decrement sp, load constant to A
~0000 0000 0000 0001 0010 0001 0010 0011
 
 load constant to B
~0000 0000 0000 0001 0000 0010 0010 0011

 store B at sp & decrement it
~0000 0000 0000 0000 0010 0000 1011 0110

 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010

 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.POP
 |----|
>| 03 |
 |----|
 
 Pops 1 byte
 
 ..., value ->
 ...
 
 increment sp & next inst
~0000 0000 0000 0011 0011 0000 0010 0011
 
 ----------------
.POP2
 |----|
>| 04 |
 |----|
 
 Pops 2 bytes
 
 ..., value1, value2 ->
 ...
 
 increment sp
~0000 0000 0000 0000 0011 0000 0000 0000
 
 increment sp & next inst
~0000 0000 0000 0011 0011 0000 0010 0011
 
 ----------------
.POP unsigned byte
 |----|------|
>| 05 | byte |
 |----|------|
 
 Pops n bytes
 Affects carry flag
 
 ..., value1, value2, ... valuen ->
 ...
 
 load a with sp low
~0000 0000 0000 0000 0000 0001 0010 1010
 
 load b with constant
~0000 0000 0000 0001 0000 0010 0010 0011
 
 addsc, store b
~0000 0110 1010 0100 0000 0010 0010 0100
 
 load a with sp high
~0000 0000 0000 0000 0000 0001 0110 1010
 
 add carry to a
~0000 0000 0000 0000 0000 0001 0010 0100
 
 store ab to sp
~0000 0000 0000 0000 0010 1000 0010 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
 
.DUP
 |----|
>| 06 |
 |----|
 
 Duplicates the value
 
 ..., value ->
 ..., value, value
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0001 0010 0010
 
 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010

 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.DUPO1
 |----|
>| 07 |
 |----|
 
 Duplicates the value over 1 byte
 
 ..., value, byte ->
 ..., value, byte, value
 
 ----------------
.DUPO2
 |----|
>| 08 |
 |----|
 
 Duplicates the value over 2 bytes
 
 ..., value, byte1, byte2 ->
 ..., value, byte1, byte2, value
 
 ----------------
.DUPON unsigned byte
 |----|------|
>| 09 | byte |
 |----|------|
 
 Duplicates the value over n bytes
 
 ..., value, byte1, byte2, ... byten ->
 ..., value, byte1, byte2, ... byten, value
 
 ----------------
.DUP2
 |----|
>| 0A |
 |----|
 
 Duplicates the 2-byte value
 
 ..., value_h, value_l ->
 ..., value_h, value_l, value_h, value_l
 
 ----------------
.DUP2O1
 |----|
>| 0B |
 |----|
 
 Duplicates the 2-byte value over 1 byte
 
 ..., value_h, value_l, byte ->
 ..., value_h, value_l, byte, value_h, value_low
 
 ----------------
.DUP2O2
 |----|
>| 0C |
 |----|
 
 Duplicates the 2-byte value over 2 bytes
 Sets the base pointer to the address of the original value_l, use DUP2O2PB to avoid this
 
 ..., value_h, value_l, byte1, byte2 ->
 ..., value_h, value_l, byte1, byte2, value_h, value_l
 
 ----------------
.DUP2O2PB
 |----|
>| 0D |
 |----|
 
 Duplicates the 2-byte value over 2 bytes, preserving the base pointer
 
 ..., value_h, value_l, byte1, byte2 ->
 ..., value_h, value_l, byte1, byte2, value_h, value_l
 
 ----------------
.DUP2ON unsigned byte
 |----|------|
>| 0E | byte |
 |----|------|
 
 Duplicates the 2-byte value over n bytes
 Sets the base pointer to the address of the original value_l, use DUP2ONPB to avoid this
 
 ..., value_h, value_l, byte1, byte2, ... byten ->
 ..., value_h, value_l, byte1, byte2, ... byten, value_h, value_l
 
 ----------------
.DUP2ONPB unsigned byte
 |----|------|
>| 0F | byte |
 |----|------|
 
 Duplicates the 2-byte value over n bytes, preserving the base pointer
 
 ..., value_h, value_l, byte1, byte2, ... byten ->
 ..., value_h, value_l, byte1, byte2, ... byten, value_h, value_l
 
 ----------------
.LOAD word OR label
 |----|------|
>| 10 | word |
 |----|------|
 
 Pushes the value at the specified memory address
 
 ... ->
 ..., value
 
 load constant to B
~0000 0000 0000 0001 0000 0010 0010 0011
 
 load constant to A
~0000 0000 0000 0001 0000 0001 0010 0011
 
 load value at AB to A, decrement sp
~0000 0000 0000 0000 0010 0001 0010 0000
 
 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011

 ----------------
.PLOAD
 |----|
>| 11 |
 |----|
 
 Pushes the value at [pointer]
 
 ..., pointer_h, pointer_l ->
 ..., value
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0010 0010 0010
 
 load sp to A
~0000 0000 0000 0000 0000 0001 0010 0010
 
 load AB to A
~0000 0000 0000 0000 0000 0001 0010 0000
 
 store A to sp
~0000 0000 0000 0000 0000 0000 1011 0010
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.ALOAD
 |----|
>| 12 |
 |----|
 
 Pushes the value at [pointer + offset]
 
 ..., pointer_h, pointer_l, offset ->
 ..., value
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0001 0010 0010
 
 load sp to B, save inverse carry of 2A
~0000 0111 1011 0000 0000 0010 0010 0010
 
 store sign extension to sp, decrement sp
~0000 0000 0000 1100 0010 0000 1010 0110

 addsc, store to sp, increment sp
~0000 0110 1010 0100 0011 0000 1010 0110
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0010 0010 0010
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0001 0010 0010
 
 addwc, store to A, decrement sp
~0000 0000 0010 0100 0010 0001 0010 0100
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0010 0010 0010
 
 load AB to A, increment sp
~0000 0000 0000 0000 0011 0001 0010 0000
 
 store A to sp
~0000 0000 0000 0000 0000 0000 1011 0010
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.ALOAD word OR label
 |----|------|
>| 13 | word |
 |----|------|
 
 Pushes the value at [pointer + offset]
 
 ..., offset ->
 ..., value
 
 ----------------
.STORE word OR label
 |----|------|
>| 18 | word |
 |----|------|
 
 Stores the value to the specified memory address
 Sets the base pointer to the specified memory address, use STOREPB to avoid this
 
 ..., value ->
 ...
 
 load constant to B
~0000 0000 0000 0001 0000 0010 0010 0011
 
 load constant to A
~0000 0000 0000 0001 0000 0001 0010 0011

 put AB in bp
~0000 0000 0000 0000 0000 0100 0000 0000
 
 load sp to A
~0000 0000 0000 0000 0000 0001 0010 0010
 
 store A at bp, increment sp
~0000 0000 0000 0000 0011 0000 1011 0001
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011

 ----------------
.STOREPB word OR label
 |----|------|
>| 19 | word |
 |----|------|
 
 Stores the value to the specified memory address while preserving the base pointer
 
 ..., value ->
 ...
 
 put bph in A, decrement sp
~0000 0000 0000 0000 0010 0001 0110 1001
 
 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010
 
 put bpl in A, decrement sp
~0000 0000 0000 0000 0010 0001 0010 1001
 
 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010
 
 load constant to B, increment sp
~0000 0000 0000 0001 0011 0010 0010 0011
 
 load constant to A, increment sp
~0000 0000 0000 0001 0011 0001 0010 0011
 
 put AB in bp
~0000 0000 0000 0000 0000 0100 0000 0000
 
 load sp to A, decrement sp
~0000 0000 0000 0000 0010 0001 0010 0010
 
 store A at bp, decrement sp
~0000 0000 0000 0000 0010 0000 1011 0001
 
 load sp to B, increment sp
~0000 0000 0000 0000 0011 0010 0010 0010
 
 load sp to A, increment sp
~0000 0000 0000 0000 0011 0001 0010 0010
 
 put AB in bp, increment sp
~0000 0000 0000 0000 0011 0100 0000 0000
 
 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.PSTORE
 |----|
>| 1A |
 |----|
 
 Stores the value to [pointer]
 Sets the base pointer to the pointer, use PSTOREPB to avoid this
 
 ..., pointer_h, pointer_l, value ->
 ...
 
 ----------------
.PSTOREPB
 |----|
>| 1B |
 |----|
 
 Stores the value to [pointer] while preserving the base pointer
 
 ..., pointer_h, pointer_l, value ->
 ...
 
 ----------------
.ASTORE
 |----|
>| 1C |
 |----|
 
 Stores the value to [pointer + offset]
 Sets the base pointer to the effective address, use ASTOREPB to avoid this
 
 ..., pointer_h, pointer_l, offset, value ->
 ...
 
 ----------------
.ASTOREPB
 |----|
>| 1D |
 |----|
 
 Stores the value to [pointer + offset] while preserving the base pointer
 
 ..., pointer_h, pointer_l, offset, value ->
 ...
 
 ----------------
.ASTORE word OR label
 |----|------|
>| 1E | word |
 |----|------|
 
 Stores the value to [pointer + offset]
 Sets the base pointer to the effective address, use ASTOREPB to avoid this
 
 ..., offset, value ->
 ...
 
 ----------------
.ASTOREPB word OR label
 |----|------|
>| 1F | word |
 |----|------|
 
 Stores the value to [pointer + offset] while preserving the base pointer
 
 ..., offset, value ->
 ...
 
 ----------------
.READ
 |----|
>| FE |
 |----|
 
 Reads the value from IO, placing it on the stack
 
 ... ->
 ..., value
 
 decrement sp, load IO to A
~0000 0000 0000 0000 0010 0001 0010 1100

 store A at sp
~0000 0000 0000 0000 0000 0000 1011 0010

 next inst
~0000 0000 0000 0011 0000 0000 0010 0011
 
 ----------------
.WRITE
 |----|
>| FF |
 |----|
 
 Writes the value on the stack to IO
 
 ..., value ->
 ...
 
 write stack to IO
~1000 0000 0000 0000 0000 0000 0010 0010
 
 increment sp & next inst
~0000 0000 0000 0011 0011 0000 0010 0011
    
 ----------------
 
 
 